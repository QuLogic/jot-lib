/*****************************************************************
 * This file is part of jot-lib (or "jot" for short):
 *   <http://code.google.com/p/jot-lib/>
 * 
 * jot-lib is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 * 
 * jot-lib is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with jot-lib.  If not, see <http://www.gnu.org/licenses/>.`
 *****************************************************************/
/*************************************************************************
 *    NAME: Loring Holden
 *    USER: lsh
 *    FILE: text2d.C
 *    DATE: Tue Apr  1 22:57:46 US/Eastern 1997
 *************************************************************************/
#include "std/support.H"
#include <GL/glew.h>

#include "disp/colors.H"
#include "geom/text2d.H"

using namespace mlib;

static int tm=DECODER_ADD(TEXT2D);

DLhandler TEXT2D::_dl;
bool      TEXT2D::_suppress_draw = false;

GLubyte rasters[][13] = {
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18}, 
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36}, 
{0x00, 0x00, 0x00, 0x66, 0x66, 0xff, 0x66, 0x66, 0xff, 0x66, 0x66, 0x00, 0x00}, 
{0x00, 0x00, 0x18, 0x7e, 0xff, 0x1b, 0x1f, 0x7e, 0xf8, 0xd8, 0xff, 0x7e, 0x18}, 
{0x00, 0x00, 0x0e, 0x1b, 0xdb, 0x6e, 0x30, 0x18, 0x0c, 0x76, 0xdb, 0xd8, 0x70}, 
{0x00, 0x00, 0x7f, 0xc6, 0xcf, 0xd8, 0x70, 0x70, 0xd8, 0xcc, 0xcc, 0x6c, 0x38}, 
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1c, 0x0c, 0x0e}, 
{0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c}, 
{0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30}, 
{0x00, 0x00, 0x00, 0x00, 0x99, 0x5a, 0x3c, 0xff, 0x3c, 0x5a, 0x99, 0x00, 0x00}, 
{0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18, 0x00, 0x00}, 
{0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x06, 0x06, 0x03, 0x03}, 
{0x00, 0x00, 0x3c, 0x66, 0xc3, 0xe3, 0xf3, 0xdb, 0xcf, 0xc7, 0xc3, 0x66, 0x3c}, 
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x38, 0x18}, 
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0xe7, 0x7e}, 
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0x07, 0x03, 0x03, 0xe7, 0x7e}, 
{0x00, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xff, 0xcc, 0x6c, 0x3c, 0x1c, 0x0c}, 
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xff}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e}, 
{0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x03, 0x03, 0xff}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e}, 
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x03, 0x7f, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e}, 
{0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x1c, 0x1c, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06}, 
{0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60}, 
{0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18, 0x0c, 0x06, 0x03, 0xc3, 0xc3, 0x7e}, 
{0x00, 0x00, 0x3f, 0x60, 0xcf, 0xdb, 0xd3, 0xdd, 0xc3, 0x7e, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18}, 
{0x00, 0x00, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e}, 
{0x00, 0x00, 0xfc, 0xce, 0xc7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc7, 0xce, 0xfc}, 
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xc0, 0xff}, 
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xff}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xcf, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e}, 
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3}, 
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e}, 
{0x00, 0x00, 0x7c, 0xee, 0xc6, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06}, 
{0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xe0, 0xf0, 0xd8, 0xcc, 0xc6, 0xc3}, 
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0}, 
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xdb, 0xff, 0xff, 0xe7, 0xc3}, 
{0x00, 0x00, 0xc7, 0xc7, 0xcf, 0xcf, 0xdf, 0xdb, 0xfb, 0xf3, 0xf3, 0xe3, 0xe3}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xe7, 0x7e}, 
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe}, 
{0x00, 0x00, 0x3f, 0x6e, 0xdf, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x66, 0x3c}, 
{0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe}, 
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0xe0, 0xc0, 0xc0, 0xe7, 0x7e}, 
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3}, 
{0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3}, 
{0x00, 0x00, 0xc3, 0xe7, 0xff, 0xff, 0xdb, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3}, 
{0x00, 0x00, 0xc3, 0x66, 0x66, 0x3c, 0x3c, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3}, 
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3}, 
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x7e, 0x0c, 0x06, 0x03, 0x03, 0xff}, 
{0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c}, 
{0x00, 0x03, 0x03, 0x06, 0x06, 0x0c, 0x0c, 0x18, 0x18, 0x30, 0x30, 0x60, 0x60}, 
{0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c}, 
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18}, 
{0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x38, 0x30, 0x70}, 
{0x00, 0x00, 0x7f, 0xc3, 0xc3, 0x7f, 0x03, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0}, 
{0x00, 0x00, 0x7e, 0xc3, 0xc0, 0xc0, 0xc0, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x03, 0x03, 0x03, 0x03, 0x03}, 
{0x00, 0x00, 0x7f, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x33, 0x1e}, 
{0x7e, 0xc3, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0}, 
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00}, 
{0x38, 0x6c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x00, 0x00, 0x0c, 0x00}, 
{0x00, 0x00, 0xc6, 0xcc, 0xf8, 0xf0, 0xd8, 0xcc, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0}, 
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78}, 
{0x00, 0x00, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xfe, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xfc, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00}, 
{0xc0, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0x00, 0x00, 0x00, 0x00}, 
{0x03, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0, 0xfe, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xfe, 0x03, 0x03, 0x7e, 0xc0, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x1c, 0x36, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x00}, 
{0x00, 0x00, 0x7e, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xc3, 0xe7, 0xff, 0xdb, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00}, 
{0xc0, 0x60, 0x60, 0x30, 0x18, 0x3c, 0x66, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xff, 0x60, 0x30, 0x18, 0x0c, 0x06, 0xff, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x0f, 0x18, 0x18, 0x18, 0x38, 0xf0, 0x38, 0x18, 0x18, 0x18, 0x0f}, 
{0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18}, 
{0x00, 0x00, 0xf0, 0x18, 0x18, 0x18, 0x1c, 0x0f, 0x1c, 0x18, 0x18, 0x18, 0xf0}, 
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x8f, 0xf1, 0x60, 0x00, 0x00, 0x00} 
};

TEXT2D::TEXT2D(const string &n, const string &s, CXYpt &p) :
   GEOM(n),
   _string(s),
   _is2d(1),
   _center(0),
   _can_intersect(0),
   _show_boxes(0)
{
   _xform = Wtransf(Wpt(p[0],p[1],0));
}

void 
TEXT2D::recompute_xform() 
{
   // If this text is attached to a 3D point, project it to screen space
   if (!_is2d) 
        _pt2d = xform().origin();
   else _pt2d = XYpt(xform().origin()[0], xform().origin()[1]);
}

const char *
TEXT2D::get_string() const
{
   const char *s;
   if (_tmp_string[0] == '\0') {
      ((TEXT2D *)this)->update();
      s = _string.c_str();
   } else
      s = _tmp_string.c_str();
   return s;
}

/*************************************************************************
 * Function Name: TEXT2D::draw
 * Parameters: 
 * Returns: int
 * Effects: 
 *************************************************************************/
int
TEXT2D::draw(
   CVIEWptr &view
   )
{
   // leave the ID reference image alone,
   // and don't draw text into screen grabs:
   if (_suppress_draw || view->grabbing_screen())
      return 0;
   
   // Get string we are going to display
   const char *s = get_string();

   // quit early if we aren't displaying anything
   if (!s || *s == '\0')
      return 0; // No triangles

   // GL initialization
   glPushAttrib(GL_ENABLE_BIT | GL_LIST_BIT | GL_CURRENT_BIT | GL_LINE_BIT);

   // No lighting
   glDisable(GL_LIGHTING);              // GL_ENABLE_BIT

   // Color
   if (_has_color) {
      glColor3dv(_color.data());        // GL_CURRENT_BIT
   } else {
      // draw black if background is light,
      // draw white if background is dark.
      if (HSVCOLOR(view->color())[2] > 0.5 && view->get_alpha() > 0.5)
         glColor3dv(Color::black.data());
      else
         glColor3dv(Color::white.data());
   }

   // Setup projection for drawing in XY coords
   glMatrixMode(GL_PROJECTION);
   glPushMatrix();
   glLoadMatrixd(view->xypt_proj().transpose().matrix());

   glMatrixMode(GL_MODELVIEW);
   glPushMatrix();
   glLoadIdentity();

   int highlight(HIGHLIGHTED.get(this));
   
   if (highlight || _center ) {
      const int border = (_show_boxes || highlight > 1) ?  9 : 5;
      BBOX2D bbox(bbox2d(border, s, true));
      int w, h;
      view->get_size(w, h);
      XYvec  pixel(2.0 / double(w), 2.0 / double(h));
      XYpt   ll(bbox.min()), tr(bbox.max());
      XYpt   lr(bbox.max()[0],bbox.min()[1]), tl(bbox.min()[0],bbox.max()[1]);
      BBOX2D bboxll(ll, ll + pixel * border);
      BBOX2D bboxlr(lr - XYvec(pixel[0],0) * border,
                    lr + XYvec(0, pixel[1])* border);
      BBOX2D bboxtl(tl - XYvec(0,pixel[1]) * border,
                    tl + XYvec(pixel[0],0) * border);
      BBOX2D bboxtr(tr - pixel * border, tr);
      if (highlight) {
         glLineWidth(float(view->line_scale()*2));      // GL_LINE_BIT
         glBegin(GL_LINE_LOOP);
         glVertex2d(bbox.min()[0], bbox.min()[1]);
         glVertex2d(bbox.max()[0], bbox.min()[1]);
         glVertex2d(bbox.max()[0], bbox.max()[1]);
         glVertex2d(bbox.min()[0], bbox.max()[1]);
         glEnd();
         if (_show_boxes || highlight > 1) {
            if (highlight == 2) glBegin(GL_POLYGON);
            else glBegin(GL_LINE_LOOP);
            glVertex2d(bboxll.min()[0], bboxll.min()[1]);
            glVertex2d(bboxll.max()[0], bboxll.min()[1]);
            glVertex2d(bboxll.max()[0], bboxll.max()[1]);
            glVertex2d(bboxll.min()[0], bboxll.max()[1]);
            glEnd();
            if (highlight == 3) glBegin(GL_POLYGON);
            else glBegin(GL_LINE_LOOP);
            glVertex2d(bboxlr.min()[0], bboxlr.min()[1]);
            glVertex2d(bboxlr.max()[0], bboxlr.min()[1]);
            glVertex2d(bboxlr.max()[0], bboxlr.max()[1]);
            glVertex2d(bboxlr.min()[0], bboxlr.max()[1]);
            glEnd();
            if (highlight == 4) glBegin(GL_POLYGON);
            else glBegin(GL_LINE_LOOP);
            glVertex2d(bboxtl.min()[0], bboxtl.min()[1]);
            glVertex2d(bboxtl.max()[0], bboxtl.min()[1]);
            glVertex2d(bboxtl.max()[0], bboxtl.max()[1]);
            glVertex2d(bboxtl.min()[0], bboxtl.max()[1]);
            glEnd();
            if (highlight == 5) glBegin(GL_POLYGON);
            else glBegin(GL_LINE_LOOP);
            glVertex2d(bboxtr.min()[0], bboxtr.min()[1]);
            glVertex2d(bboxtr.max()[0], bboxtr.min()[1]);
            glVertex2d(bboxtr.max()[0], bboxtr.max()[1]);
            glVertex2d(bboxtr.min()[0], bboxtr.max()[1]);
            glEnd();
         }
         glLineWidth(float(view->line_scale()*1));
      }
   } else {
      // If this text is attached to a 3D point, project it to screen space
      // If this text is 2D, the location is stored in the xform(), so
      // copy that into _pt2d
      recompute_xform();
   }

   // Initialize bitmaps for the letters
   if (!_dl.valid(view)) 
      initialize(view);

   // Actually draw the text
   glRasterPos2d(_pt2d[0], _pt2d[1]);
   glListBase(_dl.dl(view));
   glCallLists(strlen(s), GL_UNSIGNED_BYTE, (GLubyte *) s);

   // Restore projection matrix
   glMatrixMode(GL_PROJECTION);
   glPopMatrix();

   // Restore modelview matrix
   glMatrixMode(GL_MODELVIEW);
   glPopMatrix();

   // Restore gl state
   glPopAttrib();

   return 0; // No triangles
}

void 
TEXT2D::draw_debug(
   const char* /* str */,
   XYpt & /* pos */,
   CVIEWptr& /* view */)
{
   // XXX Incorrect behavior. Disabled for the moment
	return;
   /*
   if (view->rendering() == RCOLOR_ID) || view->grabbing_screen())
      return;
   
   if (!_dl.valid(view)) initialize(view);

   // GL initialization
   glPushAttrib(GL_ENABLE_BIT); // (GL_ENABLE_BIT)

   // No lighting
   glDisable(GL_LIGHTING);
   // Color

   glColor3dv(COLOR::white.data());
   
   // Position so 2D coordinates are in screen space
   glMatrixMode(GL_PROJECTION);
   glPushMatrix();
   glLoadMatrixd(view->xypt_proj().transpose().matrix());
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
   
   glRasterPos2d(pos[0], pos[1]);
   glPushAttrib (GL_LIST_BIT); // (GL_LIST_BIT)
   glListBase(_dl.dl(view));  
   glCallLists(strlen(str), GL_UNSIGNED_BYTE, (GLubyte *) str);
   glPopAttrib (); // (GL_LIST_BIT)   
   
   glMatrixMode(GL_PROJECTION);
   glPopMatrix();
   glMatrixMode(GL_MODELVIEW);
   glEnable(GL_LIGHTING);
   glPopAttrib(); // (GL_ENABLE_BIT)
   glFlush();
   */

}

void TEXT2D::draw_debug(const char* str, Wpt &pos, CVIEWptr& view)
{
   if (view->rendering() == RCOLOR_ID || view->grabbing_screen())
      return;
   
   if (!_dl.valid(view)) initialize(view);

   // GL initialization
   glPushAttrib(GL_ENABLE_BIT); // (GL_ENABLE_BIT)

   // No lighting
   glDisable(GL_LIGHTING);
   // Color

   //glColor3dv(COLOR::white.data());
   
   glRasterPos3dv(pos.data());
   glPushAttrib (GL_LIST_BIT); // (GL_LIST_BIT)
   glListBase(_dl.dl(view));  
   glCallLists(strlen(str), GL_UNSIGNED_BYTE, (GLubyte *) str);
   glPopAttrib (); // (GL_LIST_BIT)   
   
   glEnable(GL_LIGHTING);
   glPopAttrib(); // (GL_ENABLE_BIT)
   glFlush();

}


/*************************************************************************
 * Function Name: TEXT2D::initialize
 * Parameters: 
 * Returns: void
 * Effects: 
 *************************************************************************/
void
TEXT2D::initialize(CVIEWptr &v)
{
   GLuint i;
   glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

   unsigned int dlbase = _dl.get_dl(v, 128);
   for (i = 32; i < 127; i++) {
      glNewList(i + dlbase, GL_COMPILE);
      glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, rasters[i-32]);
      glEndList();
   }


}

RAYhit &
TEXT2D::intersect(
   RAYhit   &r,
   CWtransf &m,
   int       //uv
   ) const
{
   // Only pick text when it is associated w/ a 3D point and we know
   // the window size
   if (_can_intersect) {
      ((TEXT2D *)this)->recompute_xform(); // Update text location
      BBOX2D bbox(bbox2d(0,nullptr));      // Get bounding box

      CXYpt pick_pt(r.point() + r.vec());
      if (bbox.contains(pick_pt)) {  // picked!
         Wvec ray(r.point() - xform().origin());
         // assume text is always close to the camera
         // for now, that means 0.1 distance along viewing vector
         r.check(0, 0, 0, (TEXT2D *)this, ray.normalized(), 
                 r.point() + r.vec()*0.1, Wpt::Origin(),
                 (APPEAR *) this, XYpt());

         return r;
      }
   }

   GEOM::intersect(r,m); // Check if children were intersected
   return r;
}

/*************************************************************************
 * Function Name: text2d::bbox
 * Effects: 
 *************************************************************************/
BBOX2D
TEXT2D::bbox2d(
   int         border,
   const char *s,
   int         force
   ) const
{
   if (s == nullptr)
      s = get_string();

   int w, h;
   XYpt start, endpt;
   VIEW::peek_size(w,h);

   // Size of a pixel in NDC (-1 to 1)
   XYpt pixel(2.0 / double(w), 2.0 / double(h));
   // xsize, ysize are NDC size of each letter
   const double xsize = 10.0 * pixel[0];
   const double ysize = 13.0 * pixel[1];

   // NOTE: this function isn't really 'const' since we
   //       have to recompute cached xform values
   if (force) 
      ((TEXT2D *)this)->recompute_xform();

   // start, endpt - defines box
   start = _pt2d;
   endpt = XYpt(_pt2d[0] + double(strlen(s)) * xsize, _pt2d[1] + ysize);

   if (_center) 
   {
      double diff = endpt[0] - _pt2d[0];
      
      ((TEXT2D *)this)->_pt2d[0] -= diff/2;
      start[0] -= diff/2;
      endpt[0] -= diff/2;
   }

/*
   if (_center) 
   {
      double diff = endpt[0] - _pt2d[0];
      ((TEXT2D *)this)->_pt2d[0] = -diff / 2;
      endpt[0] = _pt2d[0] + diff;
   }
*/

   start -= pixel * border;
   endpt += pixel * border;

   return BBOX2D(start, endpt);
}

bool
TEXT2D::inside(
   CXYpt_list  &lasso
   ) const
{
   if (_is2d) return false;

   const char *s = get_string();

   // Blow this pop stand if there isn't anything to intersect
   if (!s || *s == '\0')
      return false; // No intersection

   BBOX2D bbox(bbox2d(0, s, true));
   // Intersect with corners of bounding box
   return lasso.contains(bbox.min()) ||
          lasso.contains(bbox.max()) ||
          lasso.contains(XYpt(bbox.min()[0], bbox.max()[1])) ||
          lasso.contains(XYpt(bbox.max()[0], bbox.min()[1]));
}
