/*****************************************************************
 * This file is part of jot-lib (or "jot" for short):
 *   <http://code.google.com/p/jot-lib/>
 * 
 * jot-lib is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 * 
 * jot-lib is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with jot-lib.  If not, see <http://www.gnu.org/licenses/>.`
 *****************************************************************/
/*****************************************************************
 * inflate_vert_data.H
 *****************************************************************/
#ifndef INFLATE_VERT_DATA_H_IS_INCLUDED
#define INFLATE_VERT_DATA_H_IS_INCLUDED

#include "mesh/lface.H"

#include <vector>

/*****************************************************************
 * InflateVertData:
 *
 *  data stored on a given vertex, records the vertex generated
 *  by inflation from the given vertex along each distinct normal.
 *****************************************************************/
#define CInflateVertData const InflateVertData
class InflateVertData : public SimplexData {
 public:
   //******** MANAGERS ********
   // No public constructor

   //******** RUN TIME TYPE ID ********
   DEFINE_RTTI_METHODS2("InflateVertData", SimplexData, CSimplexData*);

   //******** INTERFACE ********

   // Generate all the inflate vertices for the given vertex
   // (one for each separate normal field in the 1-ring):
   static bool gen_twins(Bvert* v, double h, CSimplexFilter& filter);

   // Do a whole list of vertices at a shot:
   static bool gen_twins(CBvert_list& verts, double h,
                         CSimplexFilter& filter) {
      bool ret = true;
      for (int i=0; i<verts.num(); i++)
         ret = gen_twins(verts[i], h, filter) && ret;
      return ret;
   }

   // Do the vertices of a given face set:
   static bool gen_twins(CBface_list& faces, double h,
                         CSimplexFilter& filter) {
      return gen_twins(faces.get_verts(), h, filter);
   }

   // find the inflate "twin" for the given face containing v
   static Bvert* get_twin(CBvert* v, CBsimplex* s);

   //******** LOOKUP ********

   // Lookup a InflateVertData* from a Bvert:
   static InflateVertData* lookup(CBvert* v) {
      return v ? (InflateVertData*)v->find_data(key()) : 0;
   }

   // Similar to above, but creates a InflateVertData if it wasn't found
   static InflateVertData* get_data(Bvert* v) {
      InflateVertData* ret = lookup(v);
      return ret ? ret : v ? new InflateVertData(v) : 0;
   }

   // Determine if the vertex has inflate data
   static bool has_data(CBvert* v) { return lookup(v) != nullptr; }

 protected:

   //******** OffsetVert ********
   class OffsetVert {
    public:
      OffsetVert(Bvert* v=0, Bsimplex* s=0) : _v(v), _s(s) {}

      Bvert*    _v;     // vertex generated by inflation
      Bsimplex* _s;     // corresponding crease element

      bool operator==(const OffsetVert& v) const {
         return ((_v == v._v) && (_s == v._s));
      }
   };

   vector<OffsetVert> _verts;

   // The unique ID used to lookup InflateVertData:
   static uintptr_t key() {
      static uintptr_t ret = (uintptr_t)static_name().c_str();
      return ret;
   }

   //******** PROTECTED CONSTRUCTOR ********
   //
   // The constructor is called (internally) only when the given
   // vertex does not already have a InflateVertData associated
   // with it.
   //
   // InflateVertData gets looked-up by its classname.
   InflateVertData(Bvert* v);
};

#endif // INFLATE_VERT_DATA_H_IS_INCLUDED

/* end of file inflate_vert_data.H */
