/*****************************************************************
 * This file is part of jot-lib (or "jot" for short):
 *   <http://code.google.com/p/jot-lib/>
 * 
 * jot-lib is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 * 
 * jot-lib is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with jot-lib.  If not, see <http://www.gnu.org/licenses/>.`
 *****************************************************************/
#ifndef TABLET_H
#define TABLET_H

#include "std/support.H"
#include "dev/tty.H"
#include "dev/dev.H"

class TabletDesc {
 public :
   enum TabletType {
         TINY,
         SMALL, 
         LARGE, 
         MULTI_MODE, 
         LCD,
         INTUOS,
         CROSS
   };

   int        _baud;
   int        _rec_len;
   string     _init_str;
   int        _yres;
   TabletType _type;

   TabletDesc()  { }
   TabletDesc(TabletType t);
   TabletDesc(int baud, int rec_len, const string &s, int yres):
              _baud(baud), _rec_len(rec_len), _init_str(s), _yres(yres) { }
};

// 
// The "TabletEvent" and "TabletQueue" classes are used in tablet
// DEVmultimode_tablet (but could also probably be used for DEVtablet, too, to
// reduce the tablet lag effects).
// 

// This class representes a single Wacom tablet event.
class TabletQueue;
class TabletEvent
{
 friend class TabletQueue;
 public:
   TabletEvent(char *buf, TabletDesc *d);
   TabletEvent() : _desc(nullptr) {}
   virtual ~TabletEvent() {}

   int          get_device()    const { return _device;  }

   double      *get_pos()             { return _pos;     }
   char         get_buttons()         { return _buttons; }

   int          touching_tablet()     { return _touching_tablet; }
   double       stylus_pressure()     { return _stylus_pressure; }

   int          is_valid() { return _is_valid; }
   int          is_eraser() { return _is_eraser;}/* only valid for intuos */

   enum { STYLUS, PUCK };
   enum { BUTTON_DOWN, MOTION, BUTTON_UP };

 protected:
   int          _device;
   TabletDesc  *_desc;

   double       _pos[2];
   char         _buttons;
   int          _touching_tablet;
   double       _stylus_pressure;
   int          _is_valid;
   int          _is_eraser;
};

// This class accepts & filters tablet button and motion events such that
// only "critical" events are saved. Basically, extra motion events (ones
// that will be out of date because there exists a more recent motion
// event) are thrown away.
// 
class TabletQueue
{
 protected:
   int          _length;
   TabletEvent *_queue;
   int          _head,_tail;

   void         do_enqueue( TabletEvent &event );
 public:
   TabletQueue() : _length(256), _queue(nullptr), _head(0), _tail(0)
                          { _queue = new TabletEvent[_length]; assert(_queue); }
   virtual ~TabletQueue() { delete _queue; }

   int          empty()   { return (_head == _tail); }
   void         reset()   { _tail = _head = 0; }

   void         enqueue( TabletEvent &event );
   TabletEvent  dequeue();
};

class Tablet : public TTYfd
{
  protected:

   double            _yres;
   DEVice_2d         _stylus;
   DEVice_buttons    _styl_buttons;
   TabletDesc        _desc;

  public:
                     Tablet(FD_MANAGER *, TabletDesc::TabletType t,
                            const char *tty = nullptr,
                            const char *name = "DEV_TABLET");
   virtual int       activate();

   DEVice_2d        &stylus()                   { return _stylus; }
   DEVice_buttons   &stylus_buttons()           { return _styl_buttons; }

   void              mod_setting_bit(int bit_num, int val);

   void              add_handler(DEVhandler *h) { _stylus.add_handler(h); 
                                                  _styl_buttons.add_handler(h);}
};

/* Button bits as generated by the TabletMultimode:
   0: pressing with tip (NOT eraser)
   1,2 switch on side of pen while in range
   3 pressing with eraser
   7 eraser in range ("touching")
   8 stylus in range ("touching")
*/

class TabletMultimode : public Tablet
{
  protected:
   DEVice_2d_absrel  _puck;
   DEVice_buttons    _puck_buttons;

   int               _device_to_report;
   int               _num_bytes_left_from_last_read;
   char              _tablet_data_buffer[4096];

   TabletQueue       _stylus_queue;
   TabletQueue       _puck_queue;

   int               _using_stylus_eraser;
   double            _stylus_pressure;

  public:

   enum { 
      STYLUS = 0,
      PUCK   = 1 
   };

           TabletMultimode(FD_MANAGER *, 
                           TabletDesc::TabletType type = TabletDesc::LARGE, 
                           const char *tty  = nullptr,
                           const char *name = "DEV_TABLET");

           void     enqueue_available_tablet_events();
   virtual void     sample();

   DEVice_2d_absrel &puck()                     { return _puck; }
   DEVice_buttons   &puck_buttons()             { return _puck_buttons; }

   double            stylus_pressure()          { return _stylus_pressure; }

   void              add_handler(DEVhandler *h) { _puck.add_handler(h); 
                                                  _puck_buttons.add_handler(h);
                                                  Tablet::add_handler(h); }

   void              reset() {
      _stylus_queue.reset();
      _puck_queue  .reset();
   }

};

#endif

