/*****************************************************************
 * This file is part of jot-lib (or "jot" for short):
 *   <http://code.google.com/p/jot-lib/>
 * 
 * jot-lib is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 * 
 * jot-lib is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with jot-lib.  If not, see <http://www.gnu.org/licenses/>.`
 *****************************************************************/
/**********************************************************************
 * ledge.C
 **********************************************************************/
#include "std/config.H"
#include "subdiv_calc.H"
#include "lmesh.H"
#include "mi.H"

Ledge::~Ledge() 
{
   // The first thing we do is kill all the adjacent faces.
   // If we don't do it now, it will happen in the Bedge
   // destructor; then the faces will call Bedge::operator-=(Bface*);
   // that will trigger a call to an Ledge virtual method,
   // but since the Ledge destructor will have completed,
   // the result is a seg fault.
   if (auto m = mesh()) {
      if (_f1) m->remove_face(_f1);
      if (_f2) m->remove_face(_f2);
      if (_adj) {
         for (Bface_list::size_type i=0; i<_adj->size(); i++)
            m->remove_face((*_adj)[i]);
      }
   }

   // and kill off subdiv elements, if any
   delete_subdiv_elements(); 
}

Ledge*
Ledge::subdiv_edge1() const 
{
   return (Ledge*)lookup_edge(lv(1)->subdiv_vertex(),_subdiv_vertex);
}

Ledge*
Ledge::subdiv_edge2() const 
{
   return (Ledge*)lookup_edge(lv(2)->subdiv_vertex(),_subdiv_vertex);
}

Ledge*
Ledge::parallel_sub_edge(int k) const
{
   Lface* f = lf(k);
   if (!(f && (f = f->subdiv_face_center())))
      return nullptr;
   return (Ledge*)f->opposite_edge(_subdiv_vertex);
}

Ledge* 
Ledge::parent_edge(int rel_level) const 
{ 
   // Get parent edge (it it exists) at the given relative
   // level up from this edge

   Ledge* e = (Ledge*)this; 
   for (int i=0; e && i<rel_level; i++) {
      Bsimplex* p = e->parent();
      if (!is_edge(p))
         return nullptr;
      e = (Ledge*)p;
   }

   return e;
}

Bsimplex* 
Ledge::ctrl_element() const 
{
   if (!_parent)
      return (Bsimplex*)this;
   if (is_edge(_parent))
      return ((Ledge*)_parent)->ctrl_element();
   if (is_face(_parent))
      return ((Lface*)_parent)->control_face();
   return nullptr;
}

uint 
Ledge::rel_level() const
{
   // Difference between subdiv level of this edge and its control element

   Bsimplex* c = ctrl_element();
   return (mesh() && c && c->mesh()) ?
      mesh()->subdiv_level() - c->mesh()->subdiv_level() : 0;
}

void
Ledge::delete_subdiv_elements()
{
   // removing the subdiv vertex also causes any
   // adjacent edges or faces in the subdivision
   // mesh to be removed -- specifically the two
   // subdivision edges generated by *this* edge

   // Make this lightweight, so you can call
   // it when you're not sure if you need to:
   if (!is_set(SUBDIV_ALLOCATED_BIT))
      return;
   clear_bit(SUBDIV_ALLOCATED_BIT);

   if (_subdiv_vertex) {
      _subdiv_vertex->mesh()->remove_vertex(_subdiv_vertex);

      // after this we need to get treated as a "dirty" edge.
      // that means the vertices have to be dirty
      lv(1)->mark_dirty();
      lv(2)->mark_dirty();
   }
}

void    
Ledge::subdiv_vert_deleted() 
{ 
   _subdiv_vertex = nullptr;

   clear_bit(SUBDIV_LOC_VALID_BIT);
   clear_bit(SUBDIV_COLOR_VALID_BIT);
   clear_bit(SUBDIV_CREASE_VALID_BIT);
}


int  
Ledge::redefine(Bvert *v, Bvert *u)
{
   delete_subdiv_elements();
   return Bedge::redefine(v,u);
}

void 
Ledge::set_new_vertices(Bvert *v1, Bvert *v2)
{
   delete_subdiv_elements();
   Bedge::set_new_vertices(v1, v2);
}

inline void
swap_edge(Bedge* e)
{
   if (e) e->do_swap();
}

bool
Ledge::do_swap()
{
   if (!swap_is_legal())
      return false;

   if (is_set(SUBDIV_ALLOCATED_BIT)) {
      Bedge* e1 = subdiv_edge1();
      Bedge* e2 = subdiv_edge2();
      Bedge* e3 = parallel_sub_edge(1);
      Bedge* e4 = parallel_sub_edge(2);
      swap_edge(e1);
      swap_edge(e2);
      swap_edge(e3);
      swap_edge(e4);
   }
   return Bedge::do_swap();
}

bool
Ledge::add_multi(Bface* f)
{
   if (Bedge::add_multi(f)) {
      push_multi(f);
      return true;
   }
   return false;
}

bool
Ledge::add_primary(Bface* f)
{
   if (Bedge::add_primary(f)) {
      push_primary(f);
      return true;
   }
   return false;
}

void
Ledge::get_sub_faces(Bface* f, Bedge* &e1, Bface* &sf1, Bedge* &e2, Bface* &sf2)
{
//     The diagram shows the situation one level down in the
//     subdivision hierarchy. This edge runs from sv1 to sv2.
//     Return values are the child/face pairs e1/sf1, e2/sf2.
//
//                        /\                                       #
//                       /  \                                      #
//                      /    \                                     #
//                     /      \                                    #
//                    /        \                                   #
//                   /          \                                  #
//                  /            \                                 #
//             sva /______________\ svb                            #
//                /\              /\                               #
//               /  \            /  \                              #
//              /    \          /    \                             #
//             /      \        /      \                            #
//            /        \      /        \                           #
//           /   sf1    \    /   sf2    \                          #
//          /            \  /            \                         #
//         /              \/              \                        #
//     sv1 -------------------------------- sv2                    #
//              e1        sve      e2                              #

   e1  = e2  = nullptr;
   sf1 = sf2 = nullptr;

   Lvert* sve = _subdiv_vertex;

   if (!sve)
      return;

   // Parent verts for sv1 and sv2:
   // (may be in reverse order from _v1 and _v2 in this edge):
   Lvert* pv1 = (Lvert*)f->leading_vert_ccw(this);
   Lvert* pv2 = (Lvert*)f->next_vert_ccw(pv1);
   assert(pv1 && pv2);

   Lvert* sv1 = pv1->subdiv_vertex();
   if (sv1) {
      e1 = sv1->lookup_edge(sve);
      if (e1) {
         Lvert* sva = ((Ledge*)f->edge_before_vert(pv1))->subdiv_vertex();
         sf1 = ::lookup_face(sv1, sve, sva);
      }
   }

   Lvert* sv2 = pv2->subdiv_vertex();
   if (sv2) {
      e2 = sv2->lookup_edge(sve);
      if (e2) {
         Lvert* svb = ((Ledge*)f->edge_from_vert(pv2))->subdiv_vertex();
         sf2 = ::lookup_face(sve, sv2, svb);
      }
   }
}

void
Ledge::push_multi(Bface* f)
{
   // If the given face is a secondary face WRT this edge,
   // then ensure its children have the same relationship
   // WRT the child edges of this edge.

   if (!is_multi(f))
      return;

   // See the diagram of child elements in
   // Ledge::get_sub_faces(), above.
   Bedge  *e1=nullptr,  *e2=nullptr;
   Bface *sf1=nullptr, *sf2=nullptr;
   get_sub_faces(f, e1, sf1, e2, sf2);

   if (e1 && sf1)
      e1->demote(sf1);
   if (e2 && sf2)
      e2->demote(sf2);
}

void
Ledge::push_primary(Bface* f)
{
   // If the given face is a primary face WRT this edge,
   // then ensure its children have the same relationship
   // WRT the child edges of this edge.

   if (!(f == _f1 || f == _f2))
      return;

   // See the diagram of child elements in
   // Ledge::get_sub_faces(), above.
   Bedge  *e1=nullptr,  *e2=nullptr;
   Bface *sf1=nullptr, *sf2=nullptr;
   get_sub_faces(f, e1, sf1, e2, sf2);

   if (e1 && sf1)
      e1->promote(sf1);
   if (e2 && sf2)
      e2->promote(sf2);
}

void
Ledge::claim_child(Ledge* child)
{
   if (!child)
      return;

   // Record this face as the child's parent
   assert(child->parent() == nullptr);
   child->set_parent(this);

   // Propagate attributes to child:
   if (is_weak())
      child->set_bit(WEAK_BIT);

   // Add more attributes here... (when needed).
}

void
Ledge::claim_child(Lvert* child)
{
   if (!child)
      return;
   assert(child->parent() == nullptr);

   // Record child, and set this face as the child's parent
   _subdiv_vertex = child;
   child->set_parent(this);

   // Propagate attributes here... (when needed).
}

void
Ledge::set_subdiv_elements(Lvert* subv)
{
   if (is_set(SUBDIV_ALLOCATED_BIT)) {
      err_msg("Ledge::set_subdiv_elements: elements already set");
      return;
   }
   set_bit(SUBDIV_ALLOCATED_BIT);

   assert(_subdiv_vertex == nullptr);
   if (!subv)
      return;
   assert(lmesh()->subdiv_mesh() == subv->lmesh());

   claim_child(subv);
   claim_child(subdiv_edge1());
   claim_child(subdiv_edge2());

   // Notify observers:
   if (_data_list)
      _data_list->notify_subdiv_gen();
}

void
Ledge::allocate_subdiv_elements()
{
   // The policy is: if the edge's subdiv vertex is allocated,
   // then the subdiv edges must already be allocated.
   //
   // So when _subdiv_vertex != nullptr this is a no-op.

   // Make this lightweight, so you can call
   // it when you're not sure if you need to:
   if (is_set(SUBDIV_ALLOCATED_BIT))
      return;
   set_bit(SUBDIV_ALLOCATED_BIT);

   assert(!_subdiv_vertex);

   LMESHptr submesh = lmesh()->subdiv_mesh();
   assert(submesh);

   // Allocate subdiv vertex in middle:
   claim_child((Lvert*)submesh->add_vertex(mid_pt()));

   if (!_subdiv_vertex)
      return;

   // Allocate two edges (making sure endpoint verts are
   // allocated).
   //
   // We preserve the directedness of the edge. I.e., the
   // forward direction of the edge is from v1 to v2, and we
   // keep the same directedness in the subdiv edges.

   Bvert* u1 = lv(1)->allocate_subdiv_vert();
   if (u1) {
      claim_child((Ledge*)submesh->add_edge(u1, _subdiv_vertex));
   }

   Bvert* u2 = lv(2)->allocate_subdiv_vert();
   if (u2) {
      claim_child((Ledge*)submesh->add_edge(_subdiv_vertex,u2));
   }

   // Notify observers:
   if (_data_list)
      _data_list->notify_subdiv_gen();
}

// Helper used below in Ledge::append_subdiv_edges():
inline bool
get_subdiv_edges(Ledge* e, int lev, vector<Bedge*>& edges)
{
   return e ? e->append_subdiv_edges(lev, edges) : false;
}

bool
Ledge::append_subdiv_edges(int lev, vector<Bedge*>& edges)
{
   // Return an ordered list of edges at the given subdiv level
   // *relative* to the level of this edge. (Level must be >= 0).
   // E.g. level 1 means one level down the subdivision hierarchy.
   // The returned edges run in the direction of v1 to v2.

   // Use depth-first search.

   if (lev < 0) {
      err_msg("Ledge::append_subdiv_edges: error: bad level: %d", lev);
      return false;
   } else if (lev == 0) {
      edges.push_back(this);
      return true;
   } else {
      return (
         get_subdiv_edges(subdiv_edge1(), lev - 1, edges) &&
         get_subdiv_edges(subdiv_edge2(), lev - 1, edges)
         );
   }
}

bool
Ledge::get_subdiv_verts(int lev, Bvert_list& ret)
{
   // Similar to append_subdiv_edges(), but returns the
   // ordered list of subdiv verts at the given level lev >= 0:

   ret.clear();
   Bedge_list edges;
   if (!append_subdiv_edges(lev, edges))
      return false;
   Lvert* v = lv(1)->subdiv_vert(lev);
   assert(v && !edges.empty() && edges.front()->contains(v));
   ret.push_back(v);
   for (Bedge_list::size_type i=0; i<edges.size(); i++) {
      ret.push_back(edges[i]->other_vertex(ret.back()));
   }
   return true;
}

inline void
set_crease(Ledge* e, unsigned short c) { if (e) e->set_crease(c); }

void
Ledge::update_subdivision()
{
   // make sure subdiv vert and edges are allocated:
   allocate_subdiv_elements();

   // our child may have been deleted in a mesh edit next
   // level down
   if (!_subdiv_vertex)
      return;

   // propagate variable sharpness crease (if needed):
   if (is_clear(SUBDIV_CREASE_VALID_BIT)) {
      set_bit(SUBDIV_CREASE_VALID_BIT);
      unsigned short subcrease = (_crease > 0) ? _crease - 1 : 0;
      ::set_crease(subdiv_edge1(), subcrease);
      ::set_crease(subdiv_edge2(), subcrease);
   }

   // calculate subdiv color (if needed):
   if (is_clear(SUBDIV_COLOR_VALID_BIT)) {
      set_bit(SUBDIV_COLOR_VALID_BIT);
      if (_v1->has_color())
         _subdiv_vertex->set_color(lmesh()->subdiv_color(this));
   }

   // calculate subdiv loc:
   if (is_clear(SUBDIV_LOC_VALID_BIT)) {
      set_bit(SUBDIV_LOC_VALID_BIT);

      // Defer to observers
      if (!_data_list || !_data_list->handle_subdiv_calc())
         _subdiv_vertex->set_subdiv_base_loc(lmesh()->subdiv_loc(this));
   }
}

unsigned short 
Ledge::subdiv_mask() const 
{
   // problems w/ caching old values...
   if (!is_set(MASK_VALID_BIT))
      ((Ledge*)this)->set_mask();
   return _mask;
}

void 
Ledge::set_mask() 
{
   set_bit(MASK_VALID_BIT);

   if (is_interior() &&
       (!is_crease() || lv(1)->is_smooth() || lv(2)->is_smooth())) {
         _mask = REGULAR_SMOOTH_EDGE;
   } else {
      _mask = REGULAR_CREASE_EDGE;
   }
}

void
Ledge::set_crease(unsigned short c)
{
   if (c != _crease) {
      Bedge::set_crease(_crease = c);
      if (c == 0)
         Bedge::clear_bit(CREASE_BIT);
      crease_changed();
   }
}

void 
Ledge::crease_changed()
{
   Bedge::crease_changed();

   clear_bit(SUBDIV_CREASE_VALID_BIT);
   mask_changed();
   lv(1)->mask_changed();
   lv(2)->mask_changed();
}

void  
Ledge::normal_changed()        
{
   Bedge::normal_changed();

   subdiv_loc_changed(); 
}

void  
Ledge::geometry_changed()
{
   Bedge::geometry_changed();

   subdiv_loc_changed(); 
}

void 
Ledge::color_changed()
{
   // XXX - should fix for non-manifold case

   if (_f1) lf(1)->color_changed();
   if (_f2) lf(2)->color_changed();
}

void 
Ledge::faces_changed()
{
   // called when faces are added or deleted

   mask_changed();       

   lv(1)->mask_changed();
   lv(2)->mask_changed();
}

void 
Ledge::mask_changed()
{
   clear_bit(MASK_VALID_BIT);
   subdiv_loc_changed();
   subdiv_color_changed();
}

/*****************************************************************
 *  get_subdiv_chain:
 *****************************************************************/
bool
get_subdiv_chain(Bvert* v1, Bvert* v2, int level, Bvert_list& ret)
{
   // Given vertices v1 and v2 joined by an Ledge, recursively
   // extract chain of subdivision vertices generated along the
   // edge at the given level (relative to the original edge):

   static bool debug = Config::get_var_bool("DEBUG_GET_SUBDIV_CHAIN",false);

   ret.clear();

   if (!(v1 && v2)) {
      err_adv(debug, "get_subdiv_chain: null vertex (level %d)", level);
      return 0;
   }

   if (!(v1->mesh() == v2->mesh() && dynamic_pointer_cast<LMESH>(v1->mesh()))){
      err_adv(debug, "get_subdiv_chain: non-LMESH (level %d)", level);
      return 0;
   }

   if (level < 0){
      err_adv(debug, "get_subdiv_chain: negative level (%d)", level);
      return 0;
   }

   Bedge* e = v1->lookup_edge(v2);
   if (!e){
      err_adv(debug, "get_subdiv_chain: verts don't form edge (level %d)",
              level);
      return 0;
   }

   if (level == 0) {
      ret.push_back(v1);
      ret.push_back(v2);
      return true;
   }

   Bvert* s1 = ((Lvert*)v1)->subdiv_vertex();
   Bvert* sv = ((Ledge*)e) ->subdiv_vertex();
   Bvert* s2 = ((Lvert*)v2)->subdiv_vertex();

   Bvert_list l1;
   Bvert_list l2;

   if (!(get_subdiv_chain(s1, sv, level-1, l1) &&
         get_subdiv_chain(sv, s2, level-1, l2))) {
      return 0;
   }
    
   l1.pop_back();
   ret = l1 + l2;
   return true;
} 

/*****************************************************************
 *  get_subdiv_chain:
 *****************************************************************/
bool 
get_subdiv_chain(CBvert_list& chain, int level, Bvert_list& ret)
{
   //  Given a connected chain of vertices, recursively extract
   //  the corresponding chain of subdivision vertices at the
   //  given level (relative to the original chain). On failure
   //  returns the empty list.

   static bool debug = Config::get_var_bool("DEBUG_GET_SUBDIV_CHAIN",false);

   ret.clear();

   if (level < 0) {
      err_adv(debug, "get_subdiv_chain: negative level (%d)", level);
      return 0;
   }

   if (chain.empty()) {
      err_adv(debug, "get_subdiv_chain: empty chain passed in");
      return true;
   }

   if (!chain.forms_chain()) {
      err_adv(debug, "get_subdiv_chain: non-chain passed in");
      return 0;
   }

   ret.reserve(((chain.size()-1) * (1 << level)) + 1);

   for (Bvert_list::size_type i=1; i<chain.size(); i++) {
      Bvert_list segment;       // sub-chain from vertex i-1 to i
      if (!get_subdiv_chain(chain[i-1], chain[i], level, segment))
         return false;
      if (!ret.empty())
         ret.pop_back();
      ret = ret + segment;
   }
      
   return true;
}

// end of file ledge.C
